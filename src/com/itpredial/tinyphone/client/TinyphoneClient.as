package com.itpredial.tinyphone.client{		import flash.errors.*;    import flash.events.*;	import flash.net.XMLSocket;	import flash.events.DataEvent;		public class TinyphoneClient	{		var xmls:XMLSocket;		var parent_:Object;		var host:String;		var port:int;		var phoneNumber:String;		var date:Date = new Date();		var time:Number = date.getTime();		var uniqueID:String = String(time + int(Math.random() * 1000));				public function TinyphoneClient(_parent_:Object, _host:String, _port:int, _phoneNumber:String)		{			parent_ = _parent_;			phoneNumber = _phoneNumber;						xmls = new XMLSocket();			xmls.connect(_host, _port);			xmls.addEventListener(Event.CONNECT, xmlsocketEvent);			xmls.addEventListener(Event.CLOSE, xmlsocketEvent);			xmls.addEventListener(IOErrorEvent.IO_ERROR, xmlsocketEvent);			xmls.addEventListener(SecurityErrorEvent.SECURITY_ERROR, xmlsocketEvent);			xmls.addEventListener(DataEvent.DATA, onDataEvent);		}				public function getPhoneNumber():String		{			return phoneNumber;		}				public function openSocket():void		{			xmls.send("CONNECT," + uniqueID + "," + phoneNumber + ",NULL");		}		public function xmlsocketEvent(evt:Event):void		{			switch(evt.type)			{				case 'ioError':					trace("ioError: " + evt.toString());					break;				case 'connect':					trace("Connected");					break;				case 'close':					trace("Disconnected");				case 'securityError':					trace("securityError: " + evt.toString());				default:						trace("");			}		}		public function onDataEvent(evt:DataEvent):void		{			var msg:String = evt.data;			var exp0:RegExp = /[/g;			var exp1:RegExp = /{/g;			var exp2:RegExp = /}/g;			var exp3:RegExp = /"/g;			var exp4:RegExp = /]/g;				msg = msg.replace(exp0, "");			msg = msg.replace(exp1, "");			msg = msg.replace(exp2, "");			msg = msg.replace(exp3, "");			msg = msg.replace(exp4, "");						var parameters:Array = msg.split(",");						var tinyphoneEvent:TinyphoneEvent = new TinyphoneEvent();						for (var i:int = 0; i < parameters.length; i++)			{				var kv:Array = parameters[i].split(":");								if (kv[0] == "id")				{					tinyphoneEvent.setId(kv[1]);				}				else if (kv[0] == "event")				{					tinyphoneEvent.setEventType(kv[1]);				}				else if (kv[0] == "value")				{					tinyphoneEvent.setValue(kv[1]);				}			}						switch (tinyphoneEvent.getEventType())			{				case "new_call":						handleNewCaller(tinyphoneEvent);						break;				case "audio_level":						handleAudioLevel(tinyphoneEvent);						break;				case "keypress":						handleKeypress(tinyphoneEvent);						break;				case "hangup":						handleHangup(tinyphoneEvent);						break;				default:						trace("");			}		}				private function handleHangup(evt:TinyphoneEvent):void		{			invokeMethod("hangupEvent", evt, true);		}				private function handleKeypress(evt:TinyphoneEvent):void		{			invokeMethod("keypressEvent", evt, false);		}				private function handleAudioLevel(evt:TinyphoneEvent):void		{			invokeMethod("audioLevelEvent", evt, false);		}				private function handleNewCaller(evt:TinyphoneEvent):void		{			evt.setCallerNumber(evt.getValue());			invokeMethod("newCallerEvent", evt, true);		}				private function invokeMethod(methodName:String, evt:TinyphoneEvent, required:Boolean):void		{			try			{				switch (methodName)				{					case "hangupEvent":							parent_.hangupEvent(evt);							break;					case "newCallerEvent":							parent_.newCallerEvent(evt);							break;					case "keypressEvent":							parent_.keypressEvent(evt);							break;					case "audioLevelEvent":							parent_.audioLevelEvent(evt);							break;					default:							trace("");				}			}			catch (e:Error)			{				if (required)				{					trace("missing required method " + methodName + "(tinyphoneEvent:TinyphoneEvent)");				}			}		}	}}